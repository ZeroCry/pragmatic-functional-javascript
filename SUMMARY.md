# Summary

* [Introduction](INTRODUCTION.md)
  * [What does "pragmatism" mean?](INTRODUCTION/what-does-pragmatism-mean.md)
* [What does "pragmatism" mean?](what-does-pragmatism-mean.md)
* [Introduction](README.md)
  * [The second chance](the-second-chance.md)
  * [Less is more](less-is-more.md)
* [Roots of the evil](roots-of-the-evil.md)
  * [Null considered harmful](roots-of-the-evil/null-considered-harmful.md)
  * Mutability can kill your hamster
  * Take care with side-effects
  * Loops are so 80's
  * The Hadouken effect
  * Somebody stop this!
* Meet ESLint
  * Restricting imperative syntax
  * Plugins to the rescue
* Modules
  * The SOLID equivalence
  * Top-level declarations
* The power of composition
  * Thinking in functions
  * Currying and partial application
  * Point-free programming
  * Piping and composing
  * Combinators
* Types
  * Why types matter
  * Flow is your friend
  * Don't abuse polymorphism
  * Algebraic data types
* Monads and functors
  * What the hell is a monad?
  * Dealing with dangerous snakes
  * Handling state
  * Exceptions are not the rule
* Async programming
  * So you still don't understand promises?
  * Futures
  * Generators and lazy evaluation
* Awesome libraries
  * Ramda
  * Folktale
* [Welcome to Fantasy Land](fantasy-land.md)
  * Unicorns and rainbows
* Hacking the compiler
  * Extending Babel
  * Sweet macros
* [A bit of theory](a-bit-of-theory.md)
  * Lambda calculus
* Functional languages targeting JavaScript
  * LiveScript
  * PureScript
  * ReasonML
  * Elm
  * ClojureScript
* Solving real world problems
  * Integrating with external libraries
  * Playing with files
  * Network requests
  * Testing
* Final considerations
  * What should I learn now?

