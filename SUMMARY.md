# Summary

## 1. Introduction

* [Introduction](introduction.md)
* [What does "pragmatism" mean?](introduction/what-does-pragmatism-mean.md)
* [The second chance](introduction/the-second-chance.md)
* [Less is more](introduction/less-is-more.md)
* [Tooling](tooling.md)

## 2. Roots of the evil

* [Null considered harmful](roots-of-the-evil/null-considered-harmful.md)
* Mutability can kill your hamster
* Take care with side-effects
* Loops are so 80's
* The Hadouken effect
* Somebody stop this!

## 3. Meet ESLint

* Restricting imperative syntax
* Plugins to the rescue

## 4. Modules

* The SOLID equivalence
* Top-level declarations

## 5. The power of composition

* Thinking in functions
* Currying and partial application
* Point-free programming
* Piping and composing
* Combinators
* Lenses

## 6. Types

* Why types matter
* Flow is your friend
* Don't abuse polymorphism
* Algebraic data types

## 7. Transforming values

* Lists
* Objects
* Functions

## 8. Monads, monoids and functors

* What the hell is a monad?
* Dealing with dangerous snakes
* Handling state
* Exceptions are not the rule

## 9. Async programming

* So you still don't understand promises?
* Futures
* Tasks
* Generators and lazy evaluation

## 10. Welcome to Fantasy Land

* Unicorns and rainbows

## 11. Hacking the compiler

* Extending Babel
* Sweet macros

## 12. A bit of theory

* Lambda calculus

## 13. Functional languages targeting JavaScript

* LiveScript
* PureScript
* ReasonML
* Elm
* ClojureScript

## 14. Solving real world problems

* Integrating with external libraries
* Validating data
* Playing with files
* Network requests
* Testing

## 15. Final considerations

* What should I learn now?

